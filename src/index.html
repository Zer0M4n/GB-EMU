<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>GameBoy Emulator - WebAssembly</title>
    <style>
        body {
            background-color: #202020;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .gb-case {
            background-color: #c0c0c0;
            padding: 20px;
            border-radius: 10px 10px 40px 10px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
        }
        .screen-border {
            background-color: #505050;
            padding: 20px 40px;
            border-radius: 10px 10px 30px 10px;
            margin-bottom: 20px;
        }
        canvas {
            background-color: #9bbc0f;
            width: 320px;
            height: 288px;
            image-rendering: pixelated;
            border: 2px solid #333;
        }
        .controls {
            text-align: center;
            font-size: 12px;
            color: #333;
        }
        
        /* Debug Panel Styles */
        .debug-panel {
            margin-top: 20px;
            background: #1a1a2e;
            border: 2px solid #4a4a6a;
            border-radius: 8px;
            padding: 15px;
            min-width: 350px;
        }
        .debug-title {
            color: #00ff00;
            font-size: 14px;
            margin-bottom: 10px;
            border-bottom: 1px solid #4a4a6a;
            padding-bottom: 5px;
        }
        .button-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }
        .btn-indicator {
            padding: 8px 4px;
            text-align: center;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            background: #333;
            color: #666;
            border: 1px solid #444;
            transition: all 0.1s;
        }
        .btn-indicator.active {
            background: #00ff00;
            color: #000;
            border-color: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        .debug-log {
            font-size: 11px;
            color: #aaa;
            max-height: 60px;
            overflow-y: auto;
            background: #0a0a15;
            padding: 8px;
            border-radius: 4px;
        }
        
        /* Audio Panel Styles */
        .audio-panel {
            margin-top: 15px;
            padding: 10px;
            background: #0a0a15;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        .audio-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .audio-title {
            color: #00aaff;
            font-size: 12px;
        }
        .audio-meter {
            width: 100px;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
        }
        .audio-meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff4444);
            transition: width 0.05s;
        }
        .mute-btn {
            padding: 8px 20px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid #00aaff;
            border-radius: 6px;
            background: transparent;
            color: #00aaff;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mute-btn:hover {
            background: #00aaff22;
        }
        .mute-btn.muted {
            background: #ff4444;
            border-color: #ff4444;
            color: white;
        }
        .mute-btn.muted:hover {
            background: #ff6666;
        }
        .audio-status {
            font-size: 11px;
            color: #666;
        }
    </style>
</head>
<body>

    <div class="gb-case">
        <div class="screen-border">
            <canvas id="lcd" width="160" height="144"></canvas>
        </div>
        <div class="controls">
            <p>CARGANDO WASM...</p>
        </div>
    </div>
    
    <!-- DEBUG PANEL -->
    <div class="debug-panel">
        <div class="debug-title">üéÆ JOYPAD DEBUG - [UI Layer]</div>
        <div class="button-grid">
            <div class="btn-indicator" id="btn-up">‚Üë UP</div>
            <div class="btn-indicator" id="btn-down">‚Üì DOWN</div>
            <div class="btn-indicator" id="btn-left">‚Üê LEFT</div>
            <div class="btn-indicator" id="btn-right">‚Üí RIGHT</div>
            <div class="btn-indicator" id="btn-a">Z = A</div>
            <div class="btn-indicator" id="btn-b">X = B</div>
            <div class="btn-indicator" id="btn-select">SPC = SEL</div>
            <div class="btn-indicator" id="btn-start">‚èé START</div>
        </div>
        <div class="debug-log" id="debug-log">Waiting for input...</div>
        
        <!-- AUDIO PANEL -->
        <div class="audio-panel">
            <div>
                <span class="audio-title">üîä AUDIO</span>
                <span class="audio-status" id="audio-status">Click to start</span>
            </div>
            <button class="mute-btn" id="mute-btn" onclick="toggleMute()">üîä SOUND ON</button>
        </div>
    </div>

   <script>
    // ============================================================
    // AUDIO STATE & WEB AUDIO API - IMPROVED VERSION
    // ============================================================
    let audioContext = null;
    let scriptNode = null;
    let isMuted = false;
    let audioInitialized = false;
    let audioUnderrunCount = 0;
    
    // Audio configuration
    const SAMPLE_RATE = 44100;
    const BUFFER_SIZE = 1024;  // Smaller = less latency, but more risk of underruns
    const TARGET_LATENCY_SAMPLES = BUFFER_SIZE * 2;  // Keep 2 buffers worth
    
    // Audio statistics for debugging
    let audioStats = {
        samplesProcessed: 0,
        underruns: 0,
        lastSamplesAvailable: 0
    };
    
    // Toggle mute function
    function toggleMute() {
        isMuted = !isMuted;
        const btn = document.getElementById('mute-btn');
        const status = document.getElementById('audio-status');
        
        if (isMuted) {
            btn.textContent = 'üîá MUTED';
            btn.classList.add('muted');
            status.textContent = 'Audio muted';
            if (Module._set_audio_muted) {
                Module._set_audio_muted(1);
            }
        } else {
            btn.textContent = 'üîä SOUND ON';
            btn.classList.remove('muted');
            status.textContent = 'Audio playing';
            if (Module._set_audio_muted) {
                Module._set_audio_muted(0);
            }
            // Resume audio context if suspended
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }
    }
    
    // Initialize Web Audio API with improved buffer handling
    async function initAudio() {
        if (audioInitialized) return;
        
        try {
            // Create audio context with desired sample rate
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: SAMPLE_RATE,
                latencyHint: 'interactive'  // Lower latency
            });
            
            console.log('[AUDIO] Context created. Sample rate: ' + audioContext.sampleRate + ' Hz');
            console.log('[AUDIO] Base latency: ' + (audioContext.baseLatency * 1000).toFixed(2) + ' ms');
            
            // Create ScriptProcessorNode
            // Note: ScriptProcessorNode is deprecated but works well for emulators
            // AudioWorklet is more complex but could be used for even lower latency
            scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1);
            
            scriptNode.onaudioprocess = function(e) {
                const outputBuffer = e.outputBuffer.getChannelData(0);
                const bufferLength = outputBuffer.length;
                
                // Check if we should output silence
                if (isMuted || !Module._fill_audio_buffer || !Module._get_audio_buffer) {
                    for (let i = 0; i < bufferLength; i++) {
                        outputBuffer[i] = 0;
                    }
                    return;
                }
                
                // Check samples available before filling
                const available = Module._get_audio_samples_available();
                audioStats.lastSamplesAvailable = available;
                
                if (available < bufferLength) {
                    // Underrun - not enough samples
                    audioStats.underruns++;
                    
                    // Log first few underruns
                    if (audioStats.underruns <= 10) {
                        console.warn('[AUDIO] Underrun #' + audioStats.underruns + 
                                   ' - available: ' + available + ', needed: ' + bufferLength);
                    }
                }
                
                // Fill the output buffer from WASM
                // This copies from ring buffer to linear output buffer
                const samplesCopied = Module._fill_audio_buffer(bufferLength);
                
                if (samplesCopied > 0) {
                    // Get pointer to the linear output buffer
                    const audioBufferPtr = Module._get_audio_buffer();
                    
                    // Read samples from WASM HEAPF32
                    // The pointer is in bytes, divide by 4 for float32 index
                    const floatArrayStart = audioBufferPtr / 4;
                    
                    // Copy samples to Web Audio output
                    for (let i = 0; i < samplesCopied; i++) {
                        outputBuffer[i] = Module.HEAPF32[floatArrayStart + i];
                    }
                    
                    // Fill any remaining with silence (smooth transition)
                    if (samplesCopied < bufferLength) {
                        const lastSample = samplesCopied > 0 ? outputBuffer[samplesCopied - 1] : 0;
                        for (let i = samplesCopied; i < bufferLength; i++) {
                            // Fade to silence to avoid pops
                            const fadeRatio = (bufferLength - i) / (bufferLength - samplesCopied);
                            outputBuffer[i] = lastSample * fadeRatio * 0.5;
                        }
                    }
                    
                    audioStats.samplesProcessed += samplesCopied;
                } else {
                    // No samples - fill with silence
                    for (let i = 0; i < bufferLength; i++) {
                        outputBuffer[i] = 0;
                    }
                }
            };
            
            // Connect to destination (speakers)
            scriptNode.connect(audioContext.destination);
            audioInitialized = true;
            
            document.getElementById('audio-status').textContent = 'Audio ready';
            console.log('[AUDIO] Web Audio API initialized successfully');
            console.log('[AUDIO] Buffer size: ' + BUFFER_SIZE + ' samples');
            console.log('[AUDIO] Latency: ~' + ((BUFFER_SIZE / SAMPLE_RATE) * 1000).toFixed(1) + ' ms');
            
            // Log audio stats periodically
            setInterval(() => {
                if (audioStats.samplesProcessed > 0 && !isMuted) {
                    console.log('[AUDIO STATS] Samples: ' + audioStats.samplesProcessed + 
                               ', Underruns: ' + audioStats.underruns +
                               ', Available: ' + audioStats.lastSamplesAvailable);
                }
            }, 5000);
            
        } catch (err) {
            console.error('[AUDIO] Failed to initialize:', err);
            document.getElementById('audio-status').textContent = 'Audio error: ' + err.message;
        }
    }
    
    // Initialize audio on first user interaction (required by browsers)
    function initAudioOnInteraction() {
        if (!audioInitialized) {
            initAudio();
        }
    }
    
    document.addEventListener('click', initAudioOnInteraction, { once: true });
    document.addEventListener('keydown', initAudioOnInteraction, { once: true });
    
    // ============================================================
    // DEBUG STATE
    // ============================================================
    const buttonState = {
        0: false, 1: false, 2: false, 3: false,  // D-Pad
        4: false, 5: false, 6: false, 7: false   // Buttons
    };
    
    const BUTTON_NAMES = ['RIGHT', 'LEFT', 'UP', 'DOWN', 'A', 'B', 'SELECT', 'START'];
    const BUTTON_ELEMENTS = {
        0: 'btn-right', 1: 'btn-left', 2: 'btn-up', 3: 'btn-down',
        4: 'btn-a', 5: 'btn-b', 6: 'btn-select', 7: 'btn-start'
    };
    
    function updateDebugUI() {
        // Update visual indicators
        for (let id = 0; id < 8; id++) {
            const el = document.getElementById(BUTTON_ELEMENTS[id]);
            if (el) {
                el.classList.toggle('active', buttonState[id]);
            }
        }
        
        // Update log
        const pressed = [];
        for (let id = 0; id < 8; id++) {
            if (buttonState[id]) pressed.push(BUTTON_NAMES[id]);
        }
        
        const logEl = document.getElementById('debug-log');
        if (pressed.length > 0) {
            logEl.textContent = `[UI DEBUG] Keys Pressed: ${pressed.join(' | ')}`;
        } else {
            logEl.textContent = 'No buttons pressed';
        }
    }
    
    // ============================================================
    // WASM MODULE
    // ============================================================
    var Module = {
        canvas: () => document.getElementById('lcd'),

        locateFile: function (path) {
            return path;
        },

        onRuntimeInitialized: function() {
            console.log("WASM Cargado y listo!");
            document.querySelector('.controls p').innerText = "‚Üê ‚Üë ‚Üí ‚Üì | Z=A | X=B | Enter=START | Space=SELECT";
            setupKeyboard();
        }
    };

    let drawCanvasCallCount = 0;
    
    function drawCanvas() {
        if (!Module || !Module._get_video_buffer) {
            return;
        }

        const bufferPointer = Module._get_video_buffer();
        if (bufferPointer === 0) {
            console.warn("[drawCanvas] Buffer pointer is null!");
            return;
        }
        
        drawCanvasCallCount++;

        // DEBUG: Log periodically to see buffer content
        if (drawCanvasCallCount === 1 || drawCanvasCallCount === 60 || drawCanvasCallCount === 120) {
            console.log(`[drawCanvas #${drawCanvasCallCount}] bufferPointer=${bufferPointer}`);
            
            // Sample pixels from different parts of the screen
            const samples = [
                { name: "TopLeft(0,0)", offset: 0 },
                { name: "Center(80,72)", offset: (72 * 160 + 80) * 4 },
                { name: "TitleArea(80,40)", offset: (40 * 160 + 80) * 4 }
            ];
            
            for (const s of samples) {
                const r = Module.HEAPU8[bufferPointer + s.offset];
                const g = Module.HEAPU8[bufferPointer + s.offset + 1];
                const b = Module.HEAPU8[bufferPointer + s.offset + 2];
                const a = Module.HEAPU8[bufferPointer + s.offset + 3];
                console.log(`  ${s.name}: RGBA(${r}, ${g}, ${b}, ${a})`);
            }
            
            // Count unique colors in first row
            const colorSet = new Set();
            for (let x = 0; x < 160; x++) {
                const off = x * 4;
                const pixel = `${Module.HEAPU8[bufferPointer+off]},${Module.HEAPU8[bufferPointer+off+1]},${Module.HEAPU8[bufferPointer+off+2]}`;
                colorSet.add(pixel);
            }
            console.log(`  Unique colors in row 0: ${colorSet.size}`);
        }

        // IMPORTANTE: Copiar los datos del heap de WASM a un nuevo array
        // ImageData puede no funcionar bien con SharedArrayBuffer o vistas del heap WASM
        const srcData = Module.HEAPU8.subarray(bufferPointer, bufferPointer + 160 * 144 * 4);
        const data = new Uint8ClampedArray(160 * 144 * 4);
        data.set(srcData);

        const canvas = document.getElementById('lcd');
        const ctx = canvas.getContext('2d');
        const imgData = new ImageData(data, 160, 144);
        ctx.putImageData(imgData, 0, 0);
    }
    
    // ============================================================
    // KEYBOARD MAPPING
    // ============================================================
    // Button IDs (must match mmu.cpp setButton):
    // 0=Right, 1=Left, 2=Up, 3=Down, 4=A, 5=B, 6=Select, 7=Start
    
    const KEY_MAP = {
        'ArrowRight': 0,
        'ArrowLeft': 1,
        'ArrowUp': 2,
        'ArrowDown': 3,
        'KeyZ': 4,
        'KeyX': 5,
        'Space': 6,
        'Enter': 7
    };
    
    function setupKeyboard() {
        document.addEventListener('keydown', function(e) {
            const buttonId = KEY_MAP[e.code];
            if (buttonId !== undefined) {
                e.preventDefault();
                
                // Avoid repeat events
                if (buttonState[buttonId]) return;
                
                buttonState[buttonId] = true;
                updateDebugUI();
                
                if (Module._set_button) {
                    console.log(`[UI‚ÜíWASM] set_button(${BUTTON_NAMES[buttonId]}, PRESSED)`);
                    Module._set_button(buttonId, 1);
                } else {
                    console.warn('[UI] Module._set_button not available!');
                }
            }
        });
        
        document.addEventListener('keyup', function(e) {
            const buttonId = KEY_MAP[e.code];
            if (buttonId !== undefined) {
                e.preventDefault();
                
                buttonState[buttonId] = false;
                updateDebugUI();
                
                if (Module._set_button) {
                    console.log(`[UI‚ÜíWASM] set_button(${BUTTON_NAMES[buttonId]}, RELEASED)`);
                    Module._set_button(buttonId, 0);
                }
            }
        });
        
        console.log("[JOYPAD] Keyboard initialized. Press keys to test!");
        updateDebugUI();
    }
</script>

{{{ SCRIPT }}}

    
</body>
</html>